/*
MIT License

Copyright (c) 2021 Kumar Chandra

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
 */
package kchandra423.kImages;

import org.imgscalr.Scalr;
import processing.core.PApplet;
import processing.core.PImage;

import java.awt.*;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;

/**
 * The KCollider class represent an Image that supports several transformations as
 * well as intersection between other KCollider with these transformations. The
 * texture class is used to represent the graphical aspect of the image. An area
 * object is used to represent the "hitbox" of this KCollider. Upon being created,
 * an Area will be generated from the texture if not already done so. ****THIS
 * IS EXTREMELY SLOW****. Area is accurate at a pixel level, and because of
 * this, please refrain from calling it excessively. Areas are generated by
 * taking all nontransparent pixels and creating an area out of it. Areas
 * objects can also be disjointed, so even non transparent shapes separated from
 * a "main" shape will be part of the hitbox. Although KImage supports gifs,
 * this class does not entirely support gifs Although things will render without
 * issue, the area will be based on the first frame of the gif, not any others.
 * All transformations transform both the area and image. Because of the slow
 * time to transform an area, areas will only be transformed if they are needed
 * (for intersection or getting bounds). It should be noted that rotations from
 * the angle happen about the corner of the image. The same is true for
 * reflections, which reflect about the vertical line that intersects the x
 * coordinate of the current location, which is also in the top left. The final
 * transformation, "reversed" simply states whether or not when the object is
 * reflected, does its angle reverse to look in the "right" direction, by
 * drawing the angle at Pi- its actual value. However a restriction of this is
 * that unexpected behavior when something is reflected, but not reversed, and
 * it is rotated by a non zero amount.
 *
 * @author Kumar Chandra
 * @see KImage
 * @see Area
 */
public class KCollider implements KImage {

    private static int defaultAreaDensity = 2;
    private final KImage image;
    private final Area area;
    private Area mostRecentArea;
    private boolean upToDate;


    /**
     * Creates a new KCollider with the specified texture. Position starts at 0,0, with
     * reflected and reversed being false
     *
     * @param t A texture that represents what this KCollider looks like
     */
    public KCollider(KImage t) {
        this(t, defaultAreaDensity);
    }

    public KCollider(KImage t, int density) {
        this.image = t;
        area = loadArea(image, density);
        mostRecentArea = (Area) area.clone();
        upToDate = true;
    }

    /**
     * Creates a new Kimage with all the specified fields. However the area is also
     * specified, which can be useful if you are creating multiple KCollider and
     * already know what your area will be. This will make it so you will only need
     * to load the area once (which can be very slow), and pass in that area to all
     * new KCollider. Another scenario in which you may want to specify the area is if
     * the hitbox of this KCollider doesnt necessarily correspond to the way it looks,
     * so you want to be able to set it yourself.
     *
     * @param t    The KImage used by this KCollider
     * @param area The specified area to use as a hitbox
     */
    public KCollider(KImage t, Area area) {
        image = t;
        this.area = area;
        update();
        upToDate = true;
    }

//    private KCollider(KImage k, Area area, int initialWidth, int initialHeight) {
//
//        image = k;
//        this.initialHeight = initialHeight;
//        this.initialWidth = initialWidth;
//
//        this.area = area;
//        update();
//        upToDate = true;
//    }

    /**
     * Loads an area from a KImage, and returns an area that is composed of all of
     * the pixels that are not transparent. THIS CALL IS EXTREMELY SLOW. ATTEMPT TO
     * USE IT SPARINGLY.
     *
     * @return An area that fits onto all nontransparent pixels of the texture.
     */
    public static Area loadArea(KImage image, int areaDensity) {
        Area area = new Area();
        for (int x = 0; x < image.getWidth(); x += areaDensity) {
            for (int y = 0; y < image.getHeight(); y += areaDensity) {
                if (image.getImage().pixels[y * image.getWidth() + x] != 0) {
                    area.add(new Area(new Rectangle(x, y, areaDensity * image.getImage().pixelDensity, areaDensity * image.getImage().pixelDensity)));
                }
            }

        }
        return area;

    }

    /**
     * Draws the KImage with all necessary transformations specified by other
     * parameters.
     *
     * @param p The Papplet to be drawn onto.
     */
    public void draw(PApplet p) {
        image.draw(p);
    }

    @Override
    public PImage getImage() {
        return image.getImage();
    }

    @Override
    public void resize(int w, int h) {
        resize(w, h, Scalr.Mode.AUTOMATIC, Scalr.Method.AUTOMATIC);
    }

    @Override
    public void scale(float stretchX, float stretchY) {
        scale(stretchX, stretchY, Scalr.Mode.AUTOMATIC, Scalr.Method.AUTOMATIC);
    }

    @Override
    public void resize(int w, int h, Scalr.Mode mode) {
        resize(w, h, mode, Scalr.Method.AUTOMATIC);
    }

    @Override
    public void scale(float stretchX, float stretchY, Scalr.Mode mode) {
        scale(stretchX, stretchY, mode, Scalr.Method.AUTOMATIC);
    }

    @Override
    public void resize(int w, int h, Scalr.Method method) {
        resize(w, h, Scalr.Mode.AUTOMATIC, method);
    }

    @Override
    public void scale(float stretchX, float stretchY, Scalr.Method method) {
        scale(stretchX, stretchY, Scalr.Mode.AUTOMATIC, method);
    }

    @Override
    public void resize(int w, int h, Scalr.Mode mode, Scalr.Method method) {
        if (w != image.getWidth() || h != image.getHeight()) {
            image.resize(w, h, mode, method);
            upToDate = false;
        }
    }

    @Override
    public void scale(float stretchX, float stretchY, Scalr.Mode mode, Scalr.Method method) {
        if (stretchX != 1 || stretchY != 1) {
            image.scale(stretchX, stretchY);
            upToDate = false;
        }
    }


    @Override
    public int getWidth() {
        return image.getWidth();
    }

    @Override
    public int getHeight() {
        return image.getHeight();
    }

    /**
     * Translates the KCollider by the specified amounts
     *
     * @param delx The amount to translate in the x direction
     * @param dely The amount to translate in the y direction
     * @post This image's area is no longer up to date
     */
    public void translate(float delx, float dely) {
        if (delx != 0 || dely != 0) {
            image.translate(delx, dely);
            upToDate = false;
        }
    }

    /**
     * Rotates the shape by the specified amount. (Added onto current angle)
     *
     * @param angle The angle in radians to be rotated by
     * @post This image's area is no longer up to date
     */
    public void rotate(float angle) {
        if (angle != 0) {
            image.rotate(angle);
            upToDate = false;
        }
    }

    /**
     * Sets whether or not the KCollider is reflected about the vertical line that
     * passes through its x coordinate. Reflections happen about the top left
     * coordinate of the image.
     *
     * @param reflected Whether or not this image is reflected
     * @post This image's area is no longer up to date
     */
    public void reflect(boolean reflected) {
        if (image.isReflected() != reflected) {
            image.reflect(reflected);
            upToDate = false;
        }
    }

    @Override
    public void reverse(boolean flag) {
        if (image.isReversed() != flag) {
            image.reverse(flag);
            upToDate = false;
        }
    }

    /**
     * Returns whether or not the shape is being reflected
     *
     * @return Whether or not the shape is reflected
     */
    public boolean isReflected() {
        return image.isReflected();
    }

    /**
     * Sets the current angle to the specified angle
     *
     * @param angle The specified angle
     * @post This image's area is no longer up to date
     */
    public void setAngle(float angle) {
        if (image.getAngle() != angle) {
            image.setAngle(angle);
            upToDate = false;
        }
    }

    /**
     * Moves the image to the specified x and y coordinates.
     *
     * @param x The new x position
     * @param y The new y position
     * @post This image's area is no longer up to date
     */
    public void moveTo(float x, float y) {
        if (image.getX() != x || image.getY() != y) {
            image.moveTo(x, y);
            upToDate = false;
        }
    }

    /**
     * Return the current x position
     *
     * @return The current x position
     */
    public float getX() {
        return image.getX();
    }

    /**
     * Returns the current y position
     *
     * @return The current y position
     */
    public float getY() {
        return image.getY();
    }


    /**
     * Returns the current angle
     *
     * @return the current angle
     */
    public float getAngle() {
        return image.getAngle();
    }

//    /**
//     * Copys the attributes of the other image onto this image. Different to a clone in that it only copys geometric properties such as rotation and translation
//     *
//     * @param other Copys the attributes of the other object
//     */
//    private void copyInformation(KCollider other) {
//        moveTo(other.getX(), other.getY());
//        setAngle(other.getAngle());
//        reverse(other.isReversed());
//        reflect(other.isReflected());
//    }


    /**
     * Returns whether or not this image is reversed
     *
     * @return Whether or not this image is reversed
     */
    public boolean isReversed() {
        return image.isReversed();
    }

    /**
     * Returns whether or not this shape's area intersects the other shapes area.
     *
     * @param other The other KCollider
     * @return Whether or not the shapes intersect
     * @post Both image's areas will be up to date
     */
    public boolean intersects(KCollider other) {
        if (!upToDate) {
            update();
        }
        Area myArea = (Area) mostRecentArea.clone();
        if (!other.upToDate) {
            other.update();
        }
        Area otherArea = other.mostRecentArea;
        myArea.intersect(otherArea);
        return !myArea.isEmpty();
    }

    /**
     * Returns a rectangle representing the boundaries of this area as the most
     * tight rectangle possible
     *
     * @return The most tighlty bounding rectangle possible
     * @post This image's area will be up to date
     */
    public Rectangle getBounds() {
        if (!upToDate) {
            update();
        }
        return mostRecentArea.getBounds();
    }

    private void update() {
        upToDate = true;
        float x = image.getX(), y = image.getY(), angle = image.getAngle();
        if (!image.isReflected()) {
            AffineTransform transform = new AffineTransform();
            transform.translate(x, y);
            transform.rotate(angle);
            mostRecentArea = area.createTransformedArea(transform);
        } else {
            AffineTransform transform = new AffineTransform();
            transform.scale(-1, 1);
            if (image.isReversed()) {
                transform.translate(-x, y);
                transform.rotate(Math.PI - angle);
            } else {
                transform.translate(-(x + image.getWidth()), y);
                transform.rotate(angle);
            }
            mostRecentArea = area.createTransformedArea(transform);
        }
    }

    /**
     * Alters the precision of areas created by this class. An area density of 1 indicates that areas will be precise to the pixel.
     * An area density will indicate that areas could be up to 3 pixels off, as the area will be 4 pixels.
     * Ex)
     * * *
     * **
     * (Pixel density of 1 approximates as)
     * * *
     * **
     * (Pixel density of 2 approximates as)
     * **
     * ****
     * **
     * While increasing this value decreases the precision of the KCollider at a squared rate,
     * doing so also reduces time to load images at a squard rate.
     *
     * @param density The new density of any KCollider created
     * @pre density >= 1
     */
    public static void setDefaultAreaDensity(int density) {
        if (density >= 1) {
            defaultAreaDensity = density;
        }
    }

    /**
     * Clones this object with all new values. HOWEVER IT IS IMPORTANT TO NOTE that
     * the texture and area of the cloned Sprite will be the same as this one. This
     * makes it so that you dont have to reload the texture or area, but could cause
     * issues if you do anything to mess alter the texture, ie resizing it.
     *
     * @return A clone of this KCollider
     */
    @Override
    public KImage clone() {
//        try {
//            Object clone = super.clone();
//        } catch (CloneNotSupportedException e) {
//            e.printStackTrace();
//        }
//
        return new KCollider(image, area);
    }
}
